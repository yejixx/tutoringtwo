// Prisma schema for Tutor Marketplace MVP

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// USER & AUTHENTICATION
// ============================================

enum UserRole {
  STUDENT
  TUTOR
  ADMIN
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String?   // Nullable for OAuth users
  firstName     String
  lastName      String
  role          UserRole  @default(STUDENT)
  avatarUrl     String?
  emailVerified DateTime? // When email was verified
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  tutorProfile           TutorProfile?
  bookingsAsStudent      Booking[]           @relation("StudentBookings")
  reviewsGiven           Review[]
  accounts               Account[]           // OAuth accounts
  verificationTokens     VerificationToken[]
  studentConversations   Conversation[]      @relation("StudentConversations")
  tutorConversations     Conversation[]      @relation("TutorConversations")
  sentMessages           Message[]           @relation("SentMessages")

  @@index([email])
}

// OAuth Account (for Google, etc.)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String  // "oauth" | "credentials"
  provider          String  // "google" | "github" | etc.
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// Email Verification Token
model VerificationToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  type      String   // "email_verification" | "password_reset"
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
}

// ============================================
// TUTOR PROFILE
// ============================================

model TutorProfile {
  id              String   @id @default(cuid())
  userId          String   @unique
  bio             String   @db.Text
  headline        String?  // Short tagline
  subjects        String[] // Array of subjects
  hourlyRate      Float
  rating          Float    @default(0)
  totalReviews    Int      @default(0)
  verified        Boolean  @default(false)
  profileComplete Boolean  @default(false)
  stripeAccountId String?  // For Stripe Connect payouts
  
  // Enhanced profile fields
  linkedinUrl     String?  // LinkedIn profile URL
  websiteUrl      String?  // Personal website URL
  location        String?  // City/Area
  languages       String[] // Languages spoken
  teachingStyle   String?  @db.Text // Teaching methodology description
  experience      String?  @db.Text // Teaching experience description
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  availabilitySlots AvailabilitySlot[]
  bookings          Booking[]          @relation("TutorBookings")
  qualifications    Qualification[]    // Academic qualifications

  @@index([userId])
  @@index([subjects])
  @@index([hourlyRate])
}

// Academic Qualifications
model Qualification {
  id              String        @id @default(cuid())
  tutorProfileId  String
  type            String        // "GCSE", "A_LEVEL", "BACHELORS", "MASTERS", "PHD", "OTHER"
  subject         String        // Subject/Field of study
  institution     String        // School/University name
  grade           String?       // Grade achieved (e.g., "A*", "2:1", "First Class")
  year            Int?          // Year completed
  verified        Boolean       @default(false) // Verification status
  createdAt       DateTime      @default(now())

  tutorProfile TutorProfile @relation(fields: [tutorProfileId], references: [id], onDelete: Cascade)

  @@index([tutorProfileId])
}

// ============================================
// AVAILABILITY
// ============================================

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

model AvailabilitySlot {
  id          String    @id @default(cuid())
  tutorId     String
  dayOfWeek   DayOfWeek
  startTime   String    // Format: "HH:mm" (24-hour)
  endTime     String    // Format: "HH:mm" (24-hour)
  isRecurring Boolean   @default(true)
  createdAt   DateTime  @default(now())

  // Relations
  tutor TutorProfile @relation(fields: [tutorId], references: [id], onDelete: Cascade)

  @@index([tutorId])
  @@index([dayOfWeek])
}

// ============================================
// BOOKINGS
// ============================================

enum BookingStatus {
  REQUESTED       // Student has requested the booking
  PENDING         // Tutor approved, waiting for payment
  CONFIRMED       // Payment received, funds held in escrow
  IN_PROGRESS     // Lesson has started
  AWAITING_REVIEW // Lesson completed, awaiting verification
  COMPLETED       // Session verified and completed, payment released
  CANCELLED       // Cancelled by either party
  REJECTED        // Tutor rejected the request
  DISPUTED        // Payment dispute raised
}

model Booking {
  id              String        @id @default(cuid())
  studentId       String
  tutorProfileId  String
  subject         String
  startTime       DateTime
  endTime         DateTime
  status          BookingStatus @default(REQUESTED)
  price           Float         // Total price for the session
  platformFee     Float         // Commission taken by platform
  tutorEarnings   Float         // Amount tutor receives
  notes           String?       @db.Text
  tutorMessage    String?       @db.Text  // Message from tutor (approval/rejection reason)
  
  // Payment fields
  stripePaymentId       String?   // Stripe payment intent ID
  stripeTransferId      String?   // Stripe transfer ID (when funds released)
  paymentHeldInEscrow   Boolean   @default(false) // True when payment captured but not transferred
  
  // Timestamp tracking
  requestedAt     DateTime      @default(now())
  approvedAt      DateTime?     // When tutor approved
  paidAt          DateTime?     // When payment was received
  lessonStartedAt DateTime?     // When lesson actually started
  lessonEndedAt   DateTime?     // When lesson actually ended
  completedAt     DateTime?     // When payment was released to tutor
  
  // Lesson verification
  tutorConfirmedStart   Boolean   @default(false)
  studentConfirmedStart Boolean   @default(false)
  tutorConfirmedEnd     Boolean   @default(false)
  studentConfirmedEnd   Boolean   @default(false)
  
  // Meeting details
  meetingLink     String?       // Video call link (Zoom, Google Meet, etc.)
  meetingNotes    String?       @db.Text  // Notes from the session
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  student      User         @relation("StudentBookings", fields: [studentId], references: [id])
  tutorProfile TutorProfile @relation("TutorBookings", fields: [tutorProfileId], references: [id])
  review       Review?

  @@index([studentId])
  @@index([tutorProfileId])
  @@index([status])
  @@index([startTime])
}

// ============================================
// REVIEWS
// ============================================

model Review {
  id        String   @id @default(cuid())
  bookingId String   @unique
  userId    String   // The student who left the review
  rating    Int      // 1-5 stars
  comment   String?  @db.Text
  createdAt DateTime @default(now())

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id])

  @@index([bookingId])
  @@index([userId])
}

// ============================================
// MESSAGING
// ============================================

model Conversation {
  id            String    @id @default(cuid())
  studentId     String    // Student who initiated the conversation
  tutorId       String    // Tutor being messaged
  lastMessageAt DateTime  @default(now())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  student  User      @relation("StudentConversations", fields: [studentId], references: [id], onDelete: Cascade)
  tutor    User      @relation("TutorConversations", fields: [tutorId], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([studentId, tutorId]) // One conversation per student-tutor pair
  @@index([studentId])
  @@index([tutorId])
  @@index([lastMessageAt])
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  senderId       String   // User who sent the message
  content        String   @db.Text
  read           Boolean  @default(false)
  createdAt      DateTime @default(now())

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("SentMessages", fields: [senderId], references: [id])

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
}
